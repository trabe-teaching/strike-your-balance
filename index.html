<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Strike your Balance</title>
  <link href="https://unpkg.com/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />

  <style>
    @font-face {
      font-family: 'ASM-Regular';
      src: url('fonts/31A5DC_3_0.eot') format('opentype'),
           url('fonts/31A5DC_3_0.woff') format('woff'),
           url('fonts/31A5DC_3_0.ttf') format('truetype');
    }

    * {
      box-sizing: border-box;
      margin: 0;
    }

    body {
      margin: 0;
      padding: 0;
      font-size: 5vh;
      line-height: 6vh;
      font-family: "ASM-Regular", sans-serif;
    }

    a {
      color: #3333ff;
      text-decoration: none;
    }

    a:hover {
      color: #ff33cc;
    }

    small {
      font-size: 60%;
    }

    .container {
      scroll-snap-type: y mandatory;
      height: 100vh;
      width: 100vw;
      overflow-x: hidden;
    }

    section {
      scroll-snap-align: start;
      height: 100vh;
      width: 100vw;
      padding: 10vh 5vw;
      display: flex;
      flex-flow: column;
      justify-content: start;
      align-items: start;
      text-align: center;
    }

    section.center,
    section.cover--first,
    section.disclaimer,
    section.meme,
    section.blue,
    section.black {
      justify-content: center;
      align-items: center;
    }

    section.disclaimer {
      color: #fff;
      background-color: rgb(157, 41, 41);
    }

    section.blue {
      color: #fff;
      background-color: #3333ff;
    }

    section.blue a {
      color: #fff;
    }

    section.blue a:hover {
      color: #ff33cc;
    }

    section.black {
      color: #fff;
      background-color: #000;
    }

    section.cover {
     flex-flow: row;
     align-items: center
    }

    section.cover > * {
      width: 35vw;
    }

    section.cover > * + * {
      margin-left: 10vw;
    }

    section.cover > div {
      display: flex;
      flex-flow: column;
    }

    section.source {
      background-color: #2d2d2d;
    }

    section.source pre {
      text-align: left;
      padding: 0 !important;
      margin: 0 !important;
      margin-top: -1em !important;
      line-height: 1 !important;
      font-size: 75% !important;
    }

    section.source pre code {
      font-size: 70% !important;
    }

    section.quote {
      background-color: #eaeaea;
      justify-content: center;
    }

    section.quote blockquote {
      margin-left: 0;
      text-align: left;
      font-size: 90%;
      line-height: 1.3;
      margin: 4vh 0;
    }

    section.quote cite {
      display: block;
      font-style: normal;
      font-size: 70%;
      color: #666;
      margin-top: 2vh;
    }

    section.quote em {
      padding: 4px;
      background-color: rgb(251, 234, 116);
      font-style: normal;
    }

    code {
      background-color: #ddd;
      font-size: 90%;
    }

    img {
      display: block;
    }

    h1 {
      font-size: 9vh;
      line-height: 10vh;
    }

    h2 {
      font-size: 7vh;
      line-height: 8vh;
    }

    h3 {
      font-size: 5vh;
      line-height: 8vh;
    }

    h1 + h2,
    h2 + h3,
    h3 + h2 {
      margin-top: 8vh;
    }

    h2 + ul {
      margin-top: 6vh;
    }

    ul {
      text-align: left;
    }

    ul > li + li {
      margin-top: 3vh;
    }

    ul ul {
      margin-top: 3vh;
      font-size: 70%;
      line-height: 100%;
    }

    ul ul > li + li {
      margin-top: 3vh;
    }

    #pagination {
      position: fixed;
      top: 2vh;
      right: 2vw;
      color: #444;
      background-color: white;
      font-size: 1vh;
      line-height: 1vh;
      padding: 0.5vh 0.25vw 0.2vh;
    }
  </style>
</head>
<body>
  <div id="pagination"></div>
  <div class="container">
    <section class="cover--first" style="position: relative">
      <h1>Trabe</h1>
      <img src="assets/trabe-logo.png" alt="Trabe logo" style="height: 40vh; margin: 6vh 0"/>
      <h2>As√≠s & David</h2>

      <div style="position:absolute; bottom: 1vh; right: 1vw; padding: 1vh 1vw; background-color: #f0f0ea; font-size: 2vh; line-height: 2vh">
        https://trabe-teaching.github.io/strike-your-balance
      </div>
    </section>

    <section>
      <h2>Context</h2>
      <ul>
        <li>We are "old" and tired üë®üèª‚Äçü¶≥üë¥üèª</li>
        <li>We develop front and back with JS (15+ years)</li>
        <li>We have developed with many other stacks: RoR, JEE, .NET...</li>
        <li>We journied from metamagic to explicitness</li>
        <li>We long for the right abstractions</li>
      </ul>
    </section>

    <section class="quote">
      <blockquote>
        I feel like 99% of being a software engineer is debugging random shit, 1% algorithms. As you gain experience you see more random shit, your random shit toolbox is ever expanding until you can figure out anything with time since it‚Äôs semi like something else in your toolbox.
      <cite>Jessie Frazelle</cite>
      </blockquote>
    </section>

    <section>
      <h2>Motivation</h2>
      <ul>
        <li>IDHO (In David's humble opinion)</li>
        <li>Developers struggle with abstractions</li>
        <li>...so, back to the basics</li>
      </ul>
    </section>

    <section class="blue">
      <h1>Strike your balance</h1>
      <h3>...or the search for the right abstraction</h3>
    </section>

    <section class="disclaimer">
      <h2>About the code examples</h2>
      <h3>Javascript, mostly naive, can be unsafe,<br/>no imports/exports</h3>
    </section>

    <section class="quote">
      <blockquote>
        Abstraction in computer science is the process of removing elements of a code or program that aren't relevant or that distract from more important elements. <em>Abstraction refers to looking at something to maintain the general form or meaning while reducing the presence of specific details</em>.
        <cite>Google ü§∑üèª‚Äç‚ôÄÔ∏è</cite>
      </blockquote>
    </section>

    <section class="center">
      <h2>Could have been "extraction"</h2>
    </section>

    <section class="center">
      <h2>An abstraction is defined<br/>by its APIs</h2>
      <h3>How do I use it. What do I get</h3>
    </section>

    <section class="center"> 
      <h2>Example</h2>
      <h3>Read a file into a string<br/>three languages, three levels of abstraction</h3>
    </section>

    <section class="source">
      <pre><code class="language-ruby">
# ruby
text = File.open("some.txt").read
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
// js - node
const buffer = await fs.readFile("some.txt");
const text = buffer.toString();
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-c">
// C
int file = open("example.txt", O_RDONLY);

struct stat file_info;
fstat(file, &file_info);

char *buffer = (char *)malloc(file_info.st_size + 1);

read(file, buffer, file_info.st_size);
buffer[file_info.st_size] = '\0';

close(file);
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>Every option has pros and cons</li>
        <li>High level: easy to use, easy to understand</li>
        <li>Low level: highly customizable, fares better with unexpected uses</li>
      </ul>
    </section>

    <section class="black">
      <h2>Every abstraction has tradeoffs<h2>
      <h3>This talk's mantra</h3>
    </section>

    <section class="center">
      <h2>Real world example<h2>
      <h3>Dependency injection</h3>
    </section>

    <section class="center">
      <h2>Option 1: Explicit dependencies</h2>
    </section>

    <section class="source">
      <pre><code class="language-js">
function updateUserPreference({ key, value, repos }) {
  // Do stuff and get an updated user
  repos.userRepo.update(updatedUser);
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const repos = {
  userRepo: userRepo(),
};

updateUserPreference({ key: "someKey", value: "someValue", repos });
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
it("updates the user preference", () => {
  const mockUpdate = jest.fn();
  const mockRepo = { update: mockUpdate };
  const repos = { userRepo: mockRepo };

  updateUserPreference({ key: "someKey", value: "someValue", repos });

  expect(mockUpdate).toHaveBeenCalledWith(/* the updatedUser */);
});
      </code></pre>
    </section>

    <section class="center">
      <h2>Option 2: Implicit dependencies</h2>
    </section>

    <section class="source">
      <pre><code class="language-js">
function updateUserPreference({ key, value }) {
  const repo = userRepo();    
  // Do stuff and get an updated user
  repo.update(updatedUser);
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
updateUserPreference({ key: "someKey", value: "someValue" });
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const mockUpdate = jest.fn();

jest.mock("user-repo.js", () => () => ({
  update: mockUpdate;
}));

it("updates the user preference", () => {
  updateUserPreference({ key: "someKey", value: "someValue" });
  expect(mockUpdate).toHaveBeenCalledWith(/* the updatedUser */);
});
      </code></pre>
    </section>

    <section class="center">
      <h2>Option 3: Both</h2>
    </section>

    <section class="source">
      <pre><code class="language-js">
function defaultRepos() {
  return {
    userRepo: userRepo(),
  };
};

function updateUserPreference({ key, value, repos = defaultRepos() }) {
  // Do stuff and get an updated user
  repos.userRepo.update(updatedUser);
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
updateUserPreference({ key: "someKey", value: "someValue" });
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
it("updates the user preference", () => {
  const mockUpdate = jest.fn();
  const mockRepo = { update: mockUpdate };
  const repos = { userRepo: mockRepo };

  updateUserPreference({ key: "someKey", value: "someValue", repos });

  expect(mockUpdate).toHaveBeenCalledWith(/* the updatedUser */);
});
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>Explicit: no magic, easy to grasp, easy to test</li>
        <li>Implicit: convenience, less boilerplate</li>
        <li>Both: convenience, easy to test</li>
      </ul>
    </section>

    <section class="black">
      <h2>Every abstraction has tradeoffs<h2>
    </section>

    <section>
      <h2>Abstraction budget</h2>
      <ul>
        <li>Less boilerplate in your app code: more in your tests</li>
        <li>Easier to work with: harder to debug</li>
        <li>Easier to grasp: harder to really understand</li>
      </ul>
    </section>

    <section class="center">
      <h2>Real world example<h2>
      <h3>A very common React abstraction</h3>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
const StorageContext = React.createContext();

function StorageProvider({ storage, children }) {
  return (
    &lt;StorageContext.Provider value={storage}&gt;
      {children}
    &lt;/StorageContext&gt;
  );
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStorage() {
  const storage = React.useContext(StorageContext);

  if (!storage) {
    throw new Error("Cannot use useStorage outside of an StorageProvider");
  }

  return storage;
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStoredState(key, initialValue) {
  const storage = useStorage();

  const [value, setValue] = React.useState(() =&gt; {
    return storage.get(key) ?? initialValue;
  });

  const setStoredValue = (newValue) =&gt; {
    setValue(newValue);
    storage.set(key, newValue);
  };

  return [ value, setStoredValue ];
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function Counter() {
  const [count, setCount] = useStoredState("count", 0);
  return &lt;button onClick={() => setCount(count + 1)}&gt;{count}&lt;/button&gt;
}


&lt;StorageProvider storage={window.localStorage}&gt;
  &lt;Counter /&gt;
&lt;/StorageProvider&gt;

      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
test("It works", () => {
  render(
    &lt;StorageProvider storage={new Map()}&gt;
      &lt;Counter /&gt;
    &lt;/StorageProvider&gt;
  );
});
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
test("Does not work", () => {
  render(&lt;Counter/&gt;);
});
      </code></pre>
    </section>

    <section class="center">
      <h2>And now, what?<h2>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStorage() {
  const storage = React.useContext(StorageContext);

  if (!storage) {
    console.error("Cannot use useStorage outside of an StorageProvider");
  }

  return storage;
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
const defaultStorage = new Map();

function useStorage() {
  const storage = React.useContext(StorageContext);

  if (process.env.NODE_ENV === "test") {
    return defaultStorage;
  }

  if (!storage) {
    throw new Error("Cannot use useStorage outside of an StorageProvider");
  }

  return storage;
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStorage({ skipCheck }) {
  const storage = React.useContext(StorageContext);

  if (!storage && !skipCheck) {
    throw new Error("Cannot use useStorage outside of an StorageProvider");
  }

  return storage;
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStoredState(key, initialValue) {
  const storage = useStorage({ skipCheck: true });

  // ...
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
const StorageContext = React.createContext(new Map());

function useStorage() {
  return React.useContext(StorageContext);
}
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>Improved safetiness implies extra constraints</li>
        <li>Do not assume how errors should be handled</li>
        <li>What do your users really need?</li>
        <li>Do not reinvent the wheel (just use React context default value)</li>
      </ul>
    </section>

    <section class="black">
      <h2>Every abstraction has tradeoffs<h2>
    </section>

    <section class="center">
      <h2>Real world example<h2>
      <h3>To couple or not to couple</h3>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
const log = logger("errorMiddleware");

function errorMiddleware(ctx, next) {
  try {
    await next();
  } catch(e) {
    log.error("Something went wrong", e.message);
    log.debug(e.stack);
    ctx.status = 500;
  }
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-yaml">
loggers:
  base:
    level: INFO
    transports:
      - console

  errorMiddleware:
    level: DEBUG
      </code></pre>
    </section>

    <section class="center">
      <h3>And then, came the lambda function</h3>
    </section>

    <section class="source">
      <pre><code class="language-js">
async function azureFn(request, context) {
  const log = logger("azureFun"); // NOPE

  try {
    // Stuff
  } catch(e) {
    log.error("Something went wrong", e.message);
    log.debug(e.stack);
    return {
      status: 500,
    };
  }
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
async function azureFn(request, context) {
  const log = logger({
    level: process.env.LOG_LEVEL,
    transports: [ azureLogTransport(context) ],
  });

  // ...
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-yaml">
loggers:
  base:
    level: INFO

  errorMiddleware:
    level: DEBUG
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const log = logger({
  ...config.loggers.base,
  ...config.loggers.errorMiddleware,
  transports: [ consoleTransport() ],
});
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-yaml">
loggers:
  base: &base
    level: INFO

  errorMiddleware:
    &lt;&lt;: *base
    level: DEBUG
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const log = logger({
  ...config.loggers.errorMiddleware,
  transports: [ consoleTransport() ],
});
      </code></pre>
    </section>

    <section class="center">
      <h3>But you've lost the option to configure the transport in the YAML?</h3>
    </section>

    <section class="center">
      <h3>Have we really?</h3>
    </section>

    <section class="source">
<pre><code class="language-js">
const transportFactories = {
  console: () =&gt; consoleTransport(),
};

function coupledLogger(key) {
  const loggerConfig = {
    ...config.loggers.base,
    ...config.loggers[key],
  };

  const transports = loggerConfig.transports.map((t) =&gt; transportFactories[t]());

  return logger({ ...loggerConfig, transports });
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const log = coupledLogger("errorMiddleware");
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>Foundations: explicitness and dependency injection</li>
        <li>Build commodities using the foundations</li>
        <li>Use plain code if you can</li>
        <li>Maybe you can have everything, sometimes</li>
      </ul>
    </section>

    <section class="black">
      <h2>Every abstraction has tradeoffs<h2>
    </section>

    <section class="center">
      <h2>Summing up</h2>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>Do not start with the abstraction. Extract later</li>
        <li>Think in terms of APIs and client code</li>
        <li>Explicit is almost always better than implicit</li>
        <li>Avoid boilerplate with extra layers</li>
        <li>Beware of the red flags: <code>storage: "memory"</code> vs <code>storage: memoryStorage()</code>
        <li>Listen to your tests</li>
      </ul>
    </section>

    <section class="quote">
      <blockquote>
        Duplication is far cheaper than the wrong abstraction
        <cite>Sandi Metz - RailsConf 2014</cite>
      </blockquote>
    </section>

    <section class="quote">
      <blockquote>
        The biggest risk of tool development is accidentally convincing yourself that 
        incidental complexity your abstraction created is essential complexity of the
        problem space.
        <br/>
        And then you think workarounds for the incidental complexity are features
        you‚Äôre proud of.
        <cite>Ryan Florence - Remix fame</cite>
      </blockquote>
    </section>

    <section class="center">
      <h2>Let's play a game!</h2>
      <h3>We picture an scenario. You tell us the problems</h3>
    </section>

    <section class="black">
      <h2>Every abstraction has tradeoffs<h2>
      <h3>This is the last one (promise)</h3>
    </section>

    <section class="blue">
      <h1>Strike your balance</h1>
      <h3>Use the right abstraction</h3>
    </section>

    <section class="black">
      <h2>Questions?</h2>
    </section>

    <section class="blue">
      <h3>Shameless plug</h3>
      <h2>We are always hiring</h2>
      <h3><a href="mailto:rrhh@trabe.io">rrhh@trabe.io</a></h3>
    </section>
  </div>

  <script>
    const observeSectionIntersection = section => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            location.assign(`#${section.id}`);
          }
        })
      }, {
        root: document.querySelector(".container"),
        threshold: 0.5,
      });

      observer.observe(section);
    }

    document.querySelectorAll("section").forEach((section, index) => {
      section.id = `slide-${index}`;

      observeSectionIntersection(section);
    });

    const updatePagination = () => {
      const totalPages = document.querySelectorAll("section").length;
      const currentPage = Number(location.hash.replace("#slide-","")) + 1;

      document.getElementById("pagination").innerHTML = `${currentPage}/${totalPages}`;
    }

    updatePagination();
    window.addEventListener("hashchange", updatePagination);
  </script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-core.min.js"></script>
	<script src="https://unpkg.com/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
