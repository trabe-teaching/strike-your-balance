<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Strike your Balance</title>
  <link href="https://unpkg.com/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />

  <style>
    @font-face {
      font-family: 'ASM-Regular';
      src: url('fonts/31A5DC_3_0.eot') format('opentype'),
           url('fonts/31A5DC_3_0.woff') format('woff'),
           url('fonts/31A5DC_3_0.ttf') format('truetype');
    }

    * {
      box-sizing: border-box;
      margin: 0;
    }

    body {
      margin: 0;
      padding: 0;
      font-size: 5vh;
      line-height: 6vh;
      font-family: "ASM-Regular", sans-serif;
    }

    a {
      color: #3333ff;
      text-decoration: none;
    }

    a:hover {
      color: #ff33cc;
    }

    small {
      font-size: 60%;
    }

    .container {
      scroll-snap-type: y mandatory;
      height: 100vh;
      width: 100vw;
      overflow-x: hidden;
    }

    section {
      scroll-snap-align: start;
      height: 100vh;
      width: 100vw;
      padding: 10vh 5vw;
      display: flex;
      flex-flow: column;
      justify-content: start;
      align-items: start;
      text-align: center;
    }

    section.center,
    section.cover--first,
    section.disclaimer,
    section.meme,
    section.blue,
    section.black {
      justify-content: center;
      align-items: center;
    }

    section.disclaimer {
      color: #fff;
      background-color: #ff3333;
    }

    section.blue {
      color: #fff;
      background-color: #3333ff;
    }

    section.blue a {
      color: #fff;
    }

    section.blue a:hover {
      color: #ff33cc;
    }

    section.black {
      color: #fff;
      background-color: #000;
    }

    section.cover {
     flex-flow: row;
     align-items: center
    }

    section.cover > * {
      width: 35vw;
    }

    section.cover > * + * {
      margin-left: 10vw;
    }

    section.cover > div {
      display: flex;
      flex-flow: column;
    }

    section.source {
      background-color: #2d2d2d;
    }

    section.source pre {
      text-align: left;
      padding: 0 !important;
      margin: 0 !important;
      margin-top: -1em !important;
      line-height: 1 !important;
      font-size: 80% !important;
    }

    section.source pre code {
      font-size: 70% !important;
    }

    section.quote blockquote {
      margin-left: 0;
      text-align: left;
      margin: 4vh 0;
    }

    section.quote em {
      padding: 4px;
      background-color: rgb(251, 234, 116);
      font-style: normal;

    }

    img {
      display: block;
    }

    h1 {
      font-size: 9vh;
      line-height: 10vh;
    }

    h2 {
      font-size: 7vh;
      line-height: 8vh;
    }

    h1 + h2,
    h3 + h1 {
      margin-top: 8vh;
    }

    h2 + ul {
      margin-top: 6vh;
    }

    ul {
      text-align: left;
    }

    ul > li + li {
      margin-top: 3vh;
    }

    ul ul {
      margin-top: 3vh;
      font-size: 70%;
      line-height: 100%;
    }

    ul ul > li + li {
      margin-top: 3vh;
    }

    #pagination {
      position: fixed;
      top: 2vh;
      right: 2vw;
      color: #444;
      background-color: white;
      font-size: 1vh;
      line-height: 1vh;
      padding: 0.5vh 0.25vw 0.2vh;
    }
  </style>
</head>
<body>
  <div id="pagination"></div>
  <div class="container">
    <section class="cover--first" style="position: relative">
      <h1>Trabe</h1>
      <img src="assets/trabe-logo.png" alt="Trabe logo" style="height: 40vh; margin: 6vh 0"/>
      <h2>As√≠s & David</h2>

      <div style="position:absolute; bottom: 1vh; right: 1vw; padding: 1vh 1vw; background-color: #f0f0ea; font-size: 2vh; line-height: 2vh">
        https://trabe-teaching.github.io/strike-your-balance
      </div>
    </section>

    <section>
      <h2>Context</h2>
      <ul>
        <li>We are "old" and tired üë®üèª‚Äçü¶≥üë¥üèª</li>
        <li>We develop front and back with JS (15+ years)</li>
        <li>We have developed with many other stacks: RoR, JEE, .NET...</li>
        <li>We journied from metamagic to explicitness</li>
        <li>We long for the right abstractions</li>
      </ul>
    </section>

    <section>
      <h2>Motivation</h2>
      <ul>
        <li>IDHO (In David's humble opinion)</li>
        <li>Rookie developers struggle with abstractions</li>
        <li>...so, back to the basics</li>
      </ul>
    </section>

    <section class="blue">
      <h1>Strike your balance</h1>
      <h4>...or the search for the right abstraction</h4>
    </section>

    <section class="disclaimer">
      <h1>About the code examples</h1>
      <h3>Javascript, mostly naive, can be unsafe, no imports/exports</h3>
    </section>

    <section class="quote">
      <h1>About abstractions...</h1>

      <blockquote>
        Abstraction in computer science is the process of removing elements of a code or program that aren't relevant or that distract from more important elements. <em>Abstraction refers to looking at something to maintain the general form or meaning while reducing the presence of specific details</em>.
      </blockquote>
    </section>

    <section class="center">
      <h1>Could have been extraction instead</h1>
    </section>

    <section class="center"> 
      <h1>Example</h1>
      <h2>Let's read a file into a string using three languages with three levels of abstraction</h2>
    </section>

    <section class="source">
      <pre><code class="language-ruby">
text = File.open("some.txt").read
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const buffer = await fs.readFile("some.txt");
const text = buffer.toString();
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-c">
int file = open("example.txt", O_RDONLY);

struct stat file_info;
fstat(file, &file_info);

char *buffer = (char *)malloc(file_info.st_size + 1);

read(file, buffer, file_info.st_size);
buffer[file_info.st_size] = '\0';

close(file);
      </code></pre>
    </section>

    <section>
      <h2>Every option has pros and cons</h2>
      <ul>
        <li>High level: easy to use, easy to understand</li>
        <li>Low level: highly customizable, fares better with unexpected uses</li>
      </ul>
    </section>

    <section class="black">
      <h1>Every abstraction has tradeoffs<h1>
      <h2>This talk's mantra</h2>
    </section>

    <section class="center">
      <h1>Real world example<h1>
      <h2>Dependency injection</h2>
    </section>

    <section class="center">
      <h1>Option 1</h1>
      <h2>Explicit dependencies</h2>
    </section>

    <section class="source">
      <pre><code class="language-js">
function updateUserPreference({ key, value, repos }) {
  // Do stuff and get an updated user
  repos.userRepo.update(updatedUser);
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const repos = {
  userRepo: userRepo(),
};

updateUserPreference({ key: "someKey", value: "someValue", repos });
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
it("updates the user preference", () => {
  const mockUpdate = jest.fn();
  const mockRepo = { update: mockUpdate };
  const repos = { userRepo: mockRepo };

  updateUserPreference({ key: "someKey", value: "someValue", repos });

  expect(mockUpdate).toHaveBeenCalledWith(/* the updatedUser */);
});
      </code></pre>
    </section>

    <section class="center">
      <h1>Option 2</h1>
      <h2>Implicit dependencies</h2>
    </section>

    <section class="source">
      <pre><code class="language-js">
function updateUserPreference({ key, value }) {
  const repo = userRepo();    
  // Do stuff and get an updated user
  repo.update(updatedUser);
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
updateUserPreference({ key: "someKey", value: "someValue" });
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
const mockUpdate = jest.fn();

jest.mock("user-repo.js", () => () => ({
  update: mockUpdate;
}));

it("updates the user preference", () => {
  updateUserPreference({ key: "someKey", value: "someValue" });
  expect(mockUpdate).toHaveBeenCalledWith(/* the updatedUser */);
});
      </code></pre>
    </section>

    <section class="center">
      <h1>Option 3</h1>
      <h2>Both</h2>
    </section>

    <section class="source">
      <pre><code class="language-js">
function defaultRepos() {
  return {
    userRepo: userRepo(),
  };
};

function updateUserPreference({ key, value, repos = defaultRepos() }) {
  // Do stuff and get an updated user
  repos.userRepo.update(updatedUser);
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
updateUserPreference({ key: "someKey", value: "someValue" });
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-js">
it("updates the user preference", () => {
  const mockUpdate = jest.fn();
  const mockRepo = { update: mockUpdate };
  const repos = { userRepo: mockRepo };

  updateUserPreference({ key: "someKey", value: "someValue", repos });

  expect(mockUpdate).toHaveBeenCalledWith(/* the updatedUser */);
});
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>Explicit: no magic, esay to grasp, easy to test</li>
        <li>Implicit: convenience, less boilerplate</li>
        <li>Both: convenience, easy to test</li>
      </ul>
    </section>

    <section class="black">
      <h1>Every abstraction has tradeoffs<h1>
    </section>

    <section class="center">
      <h1>Real world example<h1>
      <h2>A very common React abstraction</h2>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
const StorageContext = React.createContext();

function StorageProvider({ storage, children }) {
  return (
    &lt;StorageContext.Provider value={storage}&gt;
      {children}
    &lt;/StorageContext&gt;
  );
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStorage() {
  const storage = React.useContext(StorageContext);

  if (!storage) {
    throw new Error("Cannot use useStorage outside of an StorageProvider");
  }

  return storage;
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStoredState(key, initialValue) {
  const storage = useStorage();

  const [value, setValue] = React.useState(() =&gt; {
    return storage.get(key) ?? initialValue;
  });

  const setStoredValue = (newValue) =&gt; {
    setValue(newValue);
    storage.set(key, newValue);
  };

  return [ value, setStoredValue ];
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function Counter() {
  const [count, setCount] = useStoredState(0);
  return &lt;button onClick={() => setCount(count + 1)}&gt;{count}&lt;/button&gt;
}


&lt;StorageProvider storage={window.localStorage}&gt;
  &lt;MyComponent /&gt;
&lt;/StorageProvider&gt;

      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
test("It works", () => {
  render(
    &lt;StorageProvider storage={new Map()}&gt;
      &lt;MyComponent /&gt;
    &lt;/StorageProvider&gt;
  );
});
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
test("Does not work", () => {
  render(&lt;MyComponent/&gt;);
});
      </code></pre>
    </section>

    <section class="center">
      <h1>And now, what?<h1>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
function useStorage() {
  const storage = React.useContext(StorageContext);

  if (!storage) {
    console.error("Cannot use useStorage outside of an StorageProvider");
  }

  return storage;
}
      </code></pre>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
      ...TODO
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>TODO</li>
      </ul>
    </section>

    <section class="black">
      <h1>Every abstraction has tradeoffs<h1>
    </section>

    <section class="center">
      <h1>Real world examples<h1>
      <h2>To couple or not to couple</h2>
    </section>

    <section class="source">
      <pre><code class="language-jsx">
      ...TODO
      </code></pre>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>TODO</li>
      </ul>
    </section>

    <section class="black">
      <h1>Every abstraction has tradeoffs<h1>
    </section>

    <section class="center">
      <h2>Summing up</h2>
    </section>

    <section>
      <h2>You can't have everything!</h2>
      <ul>
        <li>TODO</li>
        <li>Red flags: `storage: "memory" vs `storage: memoryStorage` example 
      </ul>
    </section>

    <section class="quote">
      ...famous bad abstraction quote
    </section>

    <section class="black">
      <h1>Every abstraction has tradeoffs<h1>
    </section>

    <section class="blue">
      <h1>Strike your balance</h1>
      <h4>Use the right abstraction</h4>
    </section>

    <section class="black">
      <h1>Questions?</h1>
    </section>

    <section class="blue">
      <h3>Shameless plug</h3>
      <h1>We are always hiring</h1>
      <h2><a href="mailto:rrhh@trabe.io">rrhh@trabe.io</a></h2>
    </section>
  </div>

  <script>
    const observeSectionIntersection = section => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            location.assign(`#${section.id}`);
          }
        })
      }, {
        root: document.querySelector(".container"),
        threshold: 0.5,
      });

      observer.observe(section);
    }

    document.querySelectorAll("section").forEach((section, index) => {
      section.id = `slide-${index}`;

      observeSectionIntersection(section);
    });

    const updatePagination = () => {
      const totalPages = document.querySelectorAll("section").length;
      const currentPage = Number(location.hash.replace("#slide-","")) + 1;

      document.getElementById("pagination").innerHTML = `${currentPage}/${totalPages}`;
    }

    updatePagination();
    window.addEventListener("hashchange", updatePagination);
  </script>
  <script src="https://unpkg.com/prismjs@1.29.0/components/prism-core.min.js"></script>
	<script src="https://unpkg.com/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
